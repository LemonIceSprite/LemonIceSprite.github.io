{"pages":[],"posts":[{"title":"C语言——指针与数组","text":"什么是数据类型？对于淳朴善良的计算机来说，形形色色的数据并没有什么不同，它只是简单的认识0和1而已。那么，在实际存储的时候，它又要怎么区分各种类型的数据呢？首先让我们来看一下，在C语言中，都有哪些数据类型。 在 C 语言中，数据类型指的是用于声明不同类型的变量或函数的一个广泛的系统。变量的类型决定了变量存储占用的空间，以及如何解释存储的位模式。 C 中的类型可分为以下几种： 序号 类型与描述 1 基本类型： 它们是算术类型，包括两种类型：整数类型和浮点类型。 2 枚举类型： 它们也是算术类型，被用来定义在程序中只能赋予其一定的离散整数值的变量。 3 void 类型： 类型说明符 void 表明没有可用的值。 4 派生类型： 它们包括：指针类型、数组类型、结构类型、共用体类型和函数类型。 整数类型下表列出了关于标准整数类型的存储大小和值范围的细节： 类型 存储大小 值范围 char 1 字节 -128 到 127 或 0 到 255 unsigned char 1 字节 0 到 255 signed char 1 字节 -128 到 127 int 2 或 4 字节 -32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647 unsigned int 2 或 4 字节 0 到 65,535 或 0 到 4,294,967,295 short 2 字节 -32,768 到 32,767 unsigned short 2 字节 0 到 65,535 long 4 字节 -2,147,483,648 到 2,147,483,647 unsigned long 4 字节 0 到 4,294,967,295 浮点类型下表列出了关于标准浮点类型的存储大小、值范围和精度的细节： 类型 存储大小 值范围 精度 float 4 字节 1.2E-38 到 3.4E+38 6 位小数 double 8 字节 2.3E-308 到 1.7E+308 15 位小数 long double 16 字节 3.4E-4932 到 1.1E+4932 19 位小数 void 类型void 类型指定没有可用的值。它通常用于以下三种情况下： 序号 类型与描述 1 函数返回为空 C 中有各种函数都不返回值，或者您可以说它们返回空。不返回值的函数的返回类型为空。例如 void exit (int status); 2 函数参数为空 C 中有各种函数不接受任何参数。不带参数的函数可以接受一个 void。例如 int rand(void); 3 指针指向 void 类型为 void * 的指针代表对象的地址，而不是类型。例如，内存分配函数 void *malloc( size_t size ); 返回指向 void 的指针，可以转换为任何数据类型。 数据在内存中是怎么存储的呢？非数组变量的存储方式当我们需要一个整数类型的变量是，我们通常会这么做： 1int a = 0; 那么在实际的内存中，上面这句话的意思就是： 喂？计算机是吧？那啥，我这需要一个int型的变量，给点地方，对就是4个字节，初始值给它赋个0，下次有人问你a在哪你就带它过去哦，别忘了！ 就这样，在程序运行时的内存中，就有这么一片地方叫a，它的数据类型时是int，以后只要是对a进行操作，计算机都会回到这个地方，进行相应的读写操作。 所有的非数组变量都是这么存储的，包括整数呀，浮点数呀，指针呀。没错，指针其实也是一个变量，只不过它存储的不是数值，而是地址，地址有什么用呢？往下看就知道了。 数组变量的存储方式那么如果我们需要一个数组是，我们应该怎么做呢？答案是： 1int a[6]; 那么实际上这句话做了什么事情呢？应该是这样的： 喂？没错又是我，这次需要的地方稍微大了点，给我六个int型变量需要的地方哦，要连续的，别给我分成散的。对了，记得把分配好的地方的首地址叫做a，免得人家以后找不到了。这次人家没说初始值是啥，你看着给就行。 当我们需要一个数组时，计算机就要把所有的需要的内存一次性连续的分配好。当我们需要使用时，直接a[0] a[1] a[2] 的用就可以了。 神奇的指针在计算机的世界里，大部分数据都有着各自的数学含义，但指针是个小小的例外。它存储着一种计算机独有的数据——地址。在许多高级语言中，程序员不可以直接对内存进行操作，比如想要访问a，就必须要告诉计算机我需要对a进行一些操作。但在C语言中，除了喊a的名字让计算机帮我找到它以外，还可以直接告诉计算机a的门牌号（地址），让计算机对地址所在的元素进行操作，不管它叫a还是叫b，直接操作就行。每种数据类型都有自己的地址，int型的指针是int *，float型的指针是float *，而int *的指针则是int **。 直接利用地址对数据进行操作是有风险的。因为没有了聪明的计算机带路，程序员自己有可能会找错所需要的变量，甚至有可能会不小心对其他程序的变量进行了操作。就好比小明同学正在一边打游戏一边上网课，他本来想对队友说：“猥琐发育，别浪！”。但是粗心的程序员不小心写错了地址，结果这句话就被阴差阳错地发送到了网课的聊天窗口里边去了。这可不太好。 指针和数组的关系之前我们说过，想要访问数组中的元素是，直接用a[0] a[1]就可以访问了，那么有没有人会想，a是什么呢？眼尖的同学可能在刚才看到了，a实际上就是整个数组在内存中的起始地址，而地址正是用指针型的变量存储的。当我们想要访问a[2]时，计算机会先根据a里边的地址找到数据的起始位置，再根据指针所对应的数据类型进行2个单元（int型为4个字节）的偏移。 计算机：哦～这会需要找a[2]，让我先看看a里边存的谁家的门牌号，找到了！是找谁来着？哦对a[2]，那就往后移动2个单位。我看看，一个int是4个字节，两个int就是8个字节，往后走8个字节，就是你了！ 由于C语言是一门编译型的语言，程序所需要的内存应该在编译结束后就确定好。这就是为什么在早期的C语言标准中，不可以使用 int a[n]; 这种写法。可是在实际的使用过程中，一切都是不可确定的，比如这次我需要数组中有20个位置来存放学生的学号，下一次就可能是50个学生。如果都按照有可能出现的上限来分配的话，程序就会非常非常大，内存也是一种有限的资源，我们应该节俭一点才对。这时动态内存管理就出现了。 C 语言为内存的分配和管理提供了几个函数。这些函数可以在 &lt;stdlib.h&gt; 头文件中找到。 序号 函数和描述 1 void *calloc(int num, int size); 在内存中动态地分配 num 个长度为 size 的连续空间，并将每一个字节都初始化为 0。所以它的结果是分配了 num*size 个字节长度的内存空间，并且每个字节的值都是0。 2 void free(void *address); 该函数释放 address 所指向的内存块,释放的是动态分配的内存空间。 3 void *malloc(int num); 在堆区分配一块指定大小的内存空间，用来存放数据。这块内存空间在函数执行完成后不会被初始化，它们的值是未知的。 4 void *realloc(void *address, int newsize); 该函数重新分配内存，把内存扩展到 newsize。 有了这些内存管理函数，我们初始化数组的方式就有了新的选择： 123int *a = (int *)malloc(sizeof(int) * 6); // 基本等价于 int a[6];// sizeof(int)的返回值为一个int类型变量所需要的空间大小 之前我们使用的初始化数组的方式为静态内存分配，非常死板，不太灵活。但是有了动态内存分配之后，我们就不需要在程序运行前就确定好数据的大小，只需要在创建好一个指针后，利用动态内存分配函数找到一片合适的地方，占山为王，同时把地址返回给a就可以了。当我们需要访问数组a中的第三个元素是，用法和之前一模一样，用a[2]就可以找到了，是不是很方便。 在使用动态内存分配时需要注意，计算机的内存一般是不会自动释放的，当我们不再使用创建好的数组时，应该使用 free(a); 来释放a所代表的数组，将内存空间留给后来有需要的人。毕竟内存是一种很宝贵的资源，去看看淘宝上8G的内存条和8G的U盘价格差多少就大概有个概念了。 一维数组存储二维矩阵在平时的印象中，如果我们需要存储一个向量，就会毫不犹豫的选择用一维数组来存，而当我们需要存储一个矩阵时，二维数组看起来是个不错的选择。这时如果想进行动态内存分配，我们应该这样： 1234567int **A = (int **)malloc(sizeof(int *) * 20);for (int i = 0; i &lt; 20; i++) A[i] = (int *)malloc(sizeof(int) * 30);// ...for (int i = 0; i &lt; 20; i++) free(A[i]);free(A); 有的同学可能就会说了，这东西看起来就好像挺复杂的，人家静态分配就一句话的事，本来说好的你动态就比人家多一句 free(); 怎么现在还扯上循环了呢？不行不行，不能用动态分配了，我还是提前多分点，不就是内存吗，我还是多掏俩钱吧，省心！ 这样看起来好像的确挺麻烦的，可是有些时候我们是真的需要动态内存分配的，矩阵的大小是很难预计的，有的可能是个2*3的小矩阵，而有的则可能是上千万行的行与列的科学矩阵，这可不是有钱任性的时候。聪明的人们就在想，能不能用一维数组来表示矩阵呢？答案是可以的，让我们先来把地方先找好： 1int *A = (int *)malloc(sizeof(int) * 20 *30); 可是这是线性的呀，怎么表示二维的矩阵呢？其实只要地方有了，怎么表示这个问题，总有人可以解决的，这里就用一个矩阵打印函数来说明吧： 123456789void printMat(int *A, int m, int n) // A是一个m行n列的矩阵{ for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; n; j++) printf(\"%d \",A[i*n + j]); // 打印第i行第n列的元素 print(\"\\n\"); }} 其实就是相当于把一个二维矩阵，每一行首位相连，就把它们拼成了一个一维数组，在寻址的时候，只需要算好想找的元素在数组的哪一个位置即可。一般来说如果这个矩阵一行有n个元素，A[ i*n + j ] 就代表矩阵中的第i行第j列的元素。 至此，我们这节课的内容基本就结束啦！","link":"/2020/04/12/C%E8%AF%AD%E8%A8%80%E2%80%94%E2%80%94%E6%8C%87%E9%92%88%E4%B8%8E%E6%95%B0%E7%BB%84/"},{"title":"Shadowsocks配置日志","text":"服务端配置安装shadowsocks服务端 1pip install shadowsocks --user 安装成功后添加环境变量 编辑 .bashrc 或 .zshrc (具体路径使情况而定) 1export PATH=&quot;&quot;$PATH:.local/bin&quot; 若能成功展示shadowsocks版本，则安装成功 1ssserver --version 编写shadowsocks配置文件 1vim shadowsocks.json server后改为服务端ip地址 (ifconfig) 1234567891011{ &quot;server&quot;:&quot;0.0.0.0&quot;, &quot;local_address&quot;:&quot;172.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;port_password&quot;: { &quot;1785&quot;: &quot;12345678&quot; }, &quot;timeout&quot;:300, &quot;method&quot;:&quot;rc4-md5&quot;, &quot;fast_open&quot;: false} 启动服务端ssserver服务 1ssserver -c shadowsocks.json 若产生Traceback报错(不一定能解决，有时因为端口被占用) 更改shadowsocks中的python文件 1vim .local/lib/python3.7/site-packages/shadowsocks/crypto/openssl.py 1:%s/cleanup/reset 再次启动服务即可 客户端配置在GitHub中下载相应版本的Shadowsocks客户端 https://github.com/shadowsocks 添加服务器相关配置(ip,port,password) encryption 改为 json 文件中的 rc4-md5 将代理模式设为全局模式(Global) 大功告成","link":"/2020/04/05/Shadowsocks/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/01/06/hello-world/"}],"tags":[],"categories":[]}